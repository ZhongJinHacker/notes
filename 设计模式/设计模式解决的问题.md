```shell
编写软件过程中，程序员面临着来自耦合性、内聚性以及可维护性、可扩展性、重用性、灵活性等多方面的挑战，设计模式是为了让程序具有更好的：
1. 代码重用性(相同功能代码，不用多次编写)
2. 可读性（编程规范性）
3. 可扩展性（增加新功能时十分方便）
4. 可靠性（增加新功能后，对原来的功能没有影响）
5. 实现高内聚，低耦合的特性

# 懂得了设计模式，你就懂了面向对象分析和设计（OOA/D）的精要
```





# 设计模式七大原则（适度取舍, 取舍的艺术）:

### 1. 单一指责原则
    （一个类只负责一个职责，一个函数只解决一个问题）【如何划分职责和行为的艺术】
### 2. 接口隔离原则
    (大接口改多个小接口，原因外部不需要大接口这么多方法，更易控制）【改与不改，如何划分的艺术】
### 3. 依赖反转原则
    (即面向接口编程，尽量不要声明具体类，而是使用接口，实现解耦）
### 4. 里氏替换原则
    （能出现父类的地方就一定可以用子类代替，即不要重写父类种的已实现的方法）
### 5. 开闭原则
    （面向扩展开放，面向修改封闭，即不要修改一个已实现的类，更不要修改类中的方法，应该选择创建新类或者创建新方法的方式解决）
### 6. 迪米特法则:
    又叫最少知道原则，即对外暴露的public方法尽量少，实现高内聚；且只和直接朋友通信（直接朋友:成员、入参、出参）
### 7. 合成复用原则:
    即不要重复自己，不要在项目内copy代码，应该选择将要copy的代码抽离出来，实现多个类复用



# 类之间的关系:
### 1. 依赖（成员、出参、入参、方法种用到）、泛化（继承）、实现（接口）
### 2. 依赖的三种特例: 关联（单向一对一，双向一对一）、聚合（整体和部分的关系）、组合（整体和部分的关系，整体与部分同生共死）



# 具体设计模式与其所要解决的问题:
## 创建型模式: ***用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”***
### 1.单例模式(Singleton Pattern):
    饿汉式、懒汉式、静态饿汉式、静态内部类懒汉式、枚举懒汉式（只产生一个对象实例，考虑线程安全问题）
### 2.简单工厂模式(Simple Factory Pattern):
    又有时叫静态工厂模式，对生产的对象进行封装（工厂没有进行抽象）
### 3.工厂方法模式(Factory Method Pattern):
    对工厂进行类抽象，实现一种工厂，来生产不同的产品
### 4.抽象工厂模式(Abstract Factory Pattern):
    对工厂进行类抽象，实现不同的工厂，每一种工厂生产其对应的产品
### 5.建造者模式(Builder Pattern):
    相当于延时创建，diy成员，有效减少构造上属参数数量的一种方式
### 6.原型模式(Prototype Pattern):
    解决对象拷贝问题（比如深复制对象，或者不愿外部调用接口破坏内部数据的情况）



## 结构型模式:***用于描述如何将类或对象按某种布局组织成更大的结构***
### 1.适配器模式(Adapter Pattern):
    解决接口不匹配问题（类适配、对象适配、接口适配）
### 2.桥接模式(Bridge Pattern): 
    解决多个类（一种类别）与多个类（另一种类别）的单重组合关系（翻盖手机 全屏手机 旋转手机 + 品牌（小米 华为））
### 3.组合模式(Composite Pattern): 
    解决类与勒之间的树形关联结构（学校 学院 系 这种关系; 父节点和叶节点）
### 4装饰者模式(Decorator Pattern): 
    解决多个类与多个类的多种多重聚合关系(例子不同种类咖啡 +糖 牛奶 巧克力等)，
    与代理模式有点像，但装饰者模式可以套无限层，而代理不会这样做。
### 5.代理模式(Proxy Pattern):
    作为一个对象的“代理人”，以控制对这个对象的访问
    被代理的对象可以是远程对象、创建开销大的对象或者需要安全控制的对象
    分为： 静态代理、动态代理、CGLib代理(直接生成其代理类的子类字节码，并加入虚拟机内存的代码区)
### 6.外观模式(Facade Pattern):
    又叫门面模式，相当于聚合多个系统的适配器，解决聚合几个子系统的接口，而对外暴露的接口不同，门面类对外仅暴露聚合后的少数接口（细节在内部组织），减少耦合，高内聚
### 7.享元模式(Flyweight Pattern):
    又叫蝇量模式(即共享对象)，运用共享技术有效地支持大量细粒度的对象(与原型模式相反)；解决重复对象的内存浪费，当系统需要大量相似的对象，需要缓冲池时，不需要总是创建对象，而是去缓存池拿，可以降低内存，提高效率



## 行为型模式: ***用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责***
### 1.策略模式(Strategy Pattern):
    定义算法簇(多组不同分类的算法组)，分别封装，让它们可以相互替换
    多用聚合、组合, 少用继承（客户通过组合的方式使用策略）
    用于封装和执行不同的算法
### 2.模板方法模式(Template Method Pattern):
    定义一套解决问题的骨架和一些抽象函数，子类中重写抽象函数完成细节，不同的子类步骤相同，而每个子类中实现的步骤的细节不同
### 3.观察者模式(Observer Pattern):
    "多"对"一"，"一"发生变化时通知"多"
### 4.迭代器模式(Iterator Pattern):
    解决遍历问题, 如果类中由两个成员，一个是集合，一个是数组，要同时遍历他俩
### 5.责任链模式(Chain of Responsibility Pattern):
    职责链模式通常每个接受者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么他会把相同的请求发给下一个接收者，一次类推(最好形成环形)
    典型案例： Netty

### 6.命令模式(Command Pattern):
    相当于一个类(Invoker)为发送命令的类，由中间类(CommandController 找到对应的 command)去去找执行者去做事,实现指挥官和执行者的解耦
    举例：一个操作电灯、电视、空调（执行者）的智能家居遥控器（CommandController），遥控器上的按钮（command, 其中关联执行者）
### 7.备忘录模式(Memento Pattern):
    相当于游戏存档，好实现在一定条件后回滚或看一个对象状态的变化（比如react所谓的时间旅行）;
### 8.状态模式(State Pattern):
    解决多if else问题，一个分支是一个状态，执行该状态下的操作
### 9.访问者模式(Visitor Pattern):
    解决数据结构和操作的耦合性问题
    在被访问的类里加一个对外提供访问者的接口
    应用场景： 需要对一个对象结构中的对象进行很多不同的操作，同时避免让这些操作“污染”这些对象的类, 具体的操作封装在visitor中，通过visitor去假设对象数据作出不同的处理
### 10.中介者模式(Mediator Pattern):
    就是对应生活中的“中介”一样,由中介帮我做各个对象的操作，我只要结果
### 11.解释器模式(Interpreter Pattern):
    场景： 四则运算等（用得较少）
    用于解释自定义的场景等，比如Js解释器
